%{
// Includes the definition of symbolic tokens. The enum definition in this
// header file replaces the `enum Token {...}` you wrote in project 1.
// It also includes the declaration of the global variable `yylval` which will
// be used by code generated by Yacc/Bison.
//
// This header file is generated by Yacc/Bison from parser.y. We suggest that
// you take a look at the content of this header file - it's not long.
#include "y.tab.h"

#include <stdio.h>
#include <stdlib.h>
extern int yylex();
%}

%option yylineno

%%

"&&"                        { return TOK_AND; }                            /* operators */
"||"                        { return TOK_OR; }
"<"                         { return TOK_LESS; }
">"                         { return TOK_GREAT; }
"<="                        { return TOK_LESSEQ; }
">="                        { return TOK_GREATEQ; }
"=="                        { return TOK_EQUALEQ; }
"!="                        { return TOK_NOTEQUAL; }
"+"                         { return TOK_PLUS; }
"-"                         { return TOK_MINUS; }
"*"                         { return TOK_STAR; }
"/"                         { return TOK_SLASH; }
"="                         { return TOK_EQUAL; }
"!"                         { return TOK_EXCL; }


"class"                     { return KW_CLASS; }                                 /* keywords */
"main"                      { return MAIN; }
"int"                       { return KW_INT; }
"String"                    { return KW_STRING; }
"boolean"                   { return KW_BOOLEAN; }
"private"                   { return KW_PRIVATE; }
"public"                    { return KW_PUBLIC; }
"static"                    { return KW_STATIC; }
"void"                      { return KW_VOID; }
"System.out.print"          { return SYSTEM_OUT_PRINT; }
"System.out.println"        { return SYSTEM_OUT_PRINTLN; }
"Integer.parseInt"          { return INTEGER_PARSEINT; }
"return"                    { return KW_RETURN; }
"if"                        { return KW_IF; }
"else"                      { return KW_ELSE; }
"while"                     { return KW_WHILE; }
"new"                       { return KW_NEW; }
"true"                      { return KW_TRUE; }
"false"                     { return KW_FALSE; }
"length"                    { return KW_LENGTH; }

"."                         { return TOK_DOT; }                                 /* other terminals */
";"                         { return TOK_SEMICOLON; }
","                         { return TOK_COMA; }
"{"                         { return TOK_LBRACE; }
"}"                         { return TOK_RBRACE; }
"("                         { return TOK_LPARENT; }
")"                         { return TOK_RPARENT; }
"["                         { return TOK_LBRACKET; }
"]"                         { return TOK_RBRACKET; }

[0-9]+ {                                                                        /* identifiers */
    yylval.integer = atoi(strdup(yytext));
    return INTEGER_LITERAL;
}

[a-zA-Z][a-zA-Z0-9_]* {
    yylval.string = strdup(yytext);
    return ID;                 
}

\"([^"\\]|\\.)*\" {
    yylval.string = strdup(yytext);
    return STRING_LITERAL;                    
}

<<EOF>>                     { return 0; }

[ \t\r\n]                   { }                                                 /* whitespace */
"//".*                      { }                                                 /* inline comments */
"/\*"([^\*]|\*+[^/\*])*\*+"/" { }                                               /* block comments */

%%

int yywrap(void) {
    return 1;
}